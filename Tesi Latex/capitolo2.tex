\chapter{Analisi del progetto preesistente}
\thispagestyle{empty}
%\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}} 

\section{Breve descrizione degli strumenti coinvolti}
Si illustrano di seguito alcune principali caratteristiche degli strumenti coinvolti nel progetto già esistente.

\subsection{Monocromatore}
Un monocromatore \`e un dispositivo che scompone un singolo fascio di luce policromatica in pi\`u fasci di luce monocromatica (che contiene cio\`e onde di una sola frequenza), permettendo cos\`i di analizzare l'intensit\`a in funzione della lunghezza d'onda.\\
Nello strumento la luce policromatica entra da una fessura; tramite un sistema ottico viene inviata su un reticolo di diffrazione o ad un prisma che scompone il fascio. Una seconda fenditura raccoglie poi il fascio di una determinata lunghezza d'onda.\\
In questo progetto si considera un monocromatore Jobin-Yvon HR460. La luce che entra dalla fessura viene rifratta (?) due volte attraverso due lenti tra cui \`e interposta una griglia che scompone il fascio di luce. 

\subsection{Fotocamera}
Una fotocamera intensificata \`e una fotocamera che al posto della pellicola fotosensibile utilizza un sensore (CCD) in grado di catturare l'immagine e trasformarla in un segnale elettrico di tipo analogico. Gli impulsi elettrici vengono convertiti in digitale da un convertitore analogico/digitale in un chip di elaborazione esterno al sensore. Viene quindi generato un flusso di dati digitali atti ad essere immagazzinati in vari formati su supporto di memoria.\\
Il CCD (Charged-Coupled Device) \`e un dispositivo attraverso il quale si ottiene un segnale elettrico in uscita, in seguito a una sequenza temporizzata di impulsi, grazie al quale \`e possibile ricostruire la matrice di pixel che compongono l'immagine proiettata sulla superficie del CCD stesso. Questa informazione pu\`o essere usata come segnale analogico, e quindi essere usata per riprodurre l'immagine su un monitor, oppure pu\`o essere convertita in formato digitale.

\section{Principali funzioni}
Il progetto preesistente ha le stesse funzioni del nuovo programma richieste, con alcune eccezioni per quanto riguarda la fotocamera. Quella utilizzata precedentemente presentava alcune funzioni che la nuova fotocamera non mette a disposizione. Ad ogni modo si descriver\`a il progetto cercando di evidenziare le funzionalit\`a che necessitano di essere abbandonate a causa della diversit\`a dei due strumenti.\\
L'interfaccia non presenta alcuna divisione tra i controlli dei due strumenti e si possono quindi controllare simultaneamente senza alcuna distinzione. È chiaro che lo strumento che ha priorità in fase di inizializzazione è il monocromatore, in quanto composto da elementi fisici che devono essere riportati con movimenti meccanici ad una posizione di dafault; solo una volta che le lenti e la griglia all'interno dello strumento si trovano nella posizione iniziale è possibile cominciare ad utilizzare il programma.

\subsection{Monocromatore}
I comandi presenti per controllare il monocromatore sono gli stessi richiesti nel nuovo progetto: selezione del grating (e rispettive calibrazioni per correggere eventuali errori), impostazione della lunghezza d'onda e slit di entrata. Sono inoltre presenti dei led che mostrano eventuali errori: un errore generico in fase di inizializzazione, lunghezza d'onda inserita errata e superamento dei limiti dei valori consentiti.

\subsection{Fotocamera}
Per quanto riguarda la fotocamera si distingue fra acquisizione singola o continua ed è possibile inserire tempo di esposizione e ritardo di acquisizione dell'immagine. Si può inoltre scegliere un valore specifico di binning, fino a 1/16 per il binning verticale e fino a 1/8 per il binning orizzontale. Viene anche segnalato un'eventuale caso di saturazione con un calcolo successivo alla foto.

\subsection{Altre opzioni}
È possibile effettuare delle operazioni non collegate direttamente ai due strumenti. Oltre a visualizzare l'immagine così come è stata presa, è anche possibile visualizzare lo spettro corrispondente in seguito a determinati calcoli. Su tale spettro si possono richiedere alcune informazioni quali l'integrale su un certo intervallo della lunghezza d'onda, il numero di picchi rilevati al di sopra di una certa soglia; viene inoltre mostrato, senza bisogno di chiederlo, il valore del picco più alto alla lunghezza d'onda corrispondente e la FWHM (Full Width at Half Maximum), che corrisponde alla differenza fra i valori assunti dalla variabile indipendente lunghezza d'onda quando la variabile dipendente y (?) è pari a metà del suo valore massimo.
È disponibile un comando per l'acquisizione del background (legato però alla fotocamera): infatti nel caso in cui lo spettro venga generato in un ambiente (visivamente) ``rumoroso'' si può successivamente utilizzare il suddetto dato per sottrarlo a immagini successive, in modo da renderle il più chiare possibile.

\section {Codice del progetto preesistente}
Si analizza nella seguenti sezioni il codice del progetto preesistente, al fine di giustificare la scelta di progettazione fatta successivamente. La descrizione del codice si articola fra analisi del front panel e del block diagram, che sono i due ambienti di programmazione principale del linguaggio \emph{LabVIEW}.

\subsection{Front Panel}
\textbf{------- inserire foto front panel -------}
Il front panel è diviso in blocchi ideali che non dividono veramente il codice ma danno all'utente tale impressione.\\
In alto si trova una tab control che mostra, a seconda della selezione, l'immagine acquisita oppure lo spettro; per visualizzare lo spettro dopo aver l'immagine e viceversa è necessario riacquisire i dati. Nella sezione dedicata allo spettro sono presenti tre indicatori che mostrano il valore del picco massimo alla lunghezza d'onda corrispondente e il valore della FWHM in mm.\\
La prima fascia di pannelli è composta da tre parti. La prima contiene un bottone booleano con cui si richiede il numero di picchi oltre una certa soglia, i cui valori vengono visualizzati in indicatori di array. La seconda permette di inserire gli estremi di un intervallo di lunghezza d'onda e di richiederne, attraverso un bottone booleano, l'integrale. La terza parte non è delimitata da un vero e proprio pannello ma contiene due indicatori di versione (main e boot) del monocromatore, un indicatore della acquisizioni fino a quel momento e il bottone booleano di uscita.\\
La seconda fascia è divisa in due parti. La prima, dedicata alla fotocamera, contiene un bottone booleano per acquisizione singola e uno per quella continua, due controlli e rispettivi indicatori per ritardo ed esposizione, due quadranti per impostare il binning verticale e orizzontale, un led di indicazione di un'eventuale saturazione e un controllo per inserire il numero di pixel su cui fare la media per generare lo spettro. La seconda parte contiene invece controlli e indicatori per il monocromatore: bottone booleano per il grating (1200 o 2400) e rispettivi controlli per inserire la calibrazione in entrambi i casi, un controllo per inserire la lunghezza d'onda e uno per la slit di entrata, due indicatori per mostrarne i valori reali, e tre led che indicano se il monocromatore è stato correttamente inizializzato o se sono presenti errori generici, lunghezza d'onda non valida e superamento dei limiti consentiti.\\
La terza fascia è divisa in quattro parti. Nella prima c'è la possibilità di salvare i dati con un file path predefinito (calcolato secondo le impostazioni del programma) oppure da inserire manualmente. Nella seconda parte è possibile selezionare il modo di acquisizione della foto, via software (impostazione di dafault), trigger esterno al fronte di salita o trigger esterno al fronte di discesa; con un bottone booleano si modifica la modalità e un led indica se il programma è in attesa di un trigger. La quarte parte indica la temperatura del CCD e della board (?) della camera.

\subsection{Block Diagram}
\textbf{------- inserire foto block diagram -------}
Il block diagram è composto di una macro flat sequence (sequenza che forza il flusso dei dati in una determinata sequenza scelta dal programmatore) divisa in tre blocchi: il primo che delimita l'inizializzazione degli strumenti, il secondo contiene il codice principale del programma, e il terzo chiude in modo corretto la fotocamera.

\subsubsection{Primo blocco}
Questo blocco è dedicato principalmente all'inizializzazione del monocromatore. È presente un'ulteriore flat sequence di 3 blocchi. Nel primo viene invocato il subVI \emph{StartUp.vi} che inizializza il monocromatore e riporta i componenti interni alle posizioni di default. Questo subVI restituisce in uscita una lista di errori e le informazioni riguardo il numero di versione del monocromatore. Nel secondo blocco è presente un timer che mette in pausa il programma per 1 secondo e nel terzo blocco il led di inizializzazione viene commutato a vero per indicare l'avvenuta inizializzazione dello strumento.\\
Oltre al subVI del monocromatore ne vengono chiamati altri due che riguardano la fotocamera: \emph{SCSetBoard.vi} e \emph{SCSetMode.vi} servono per inizializzare la scheda della fotocamera e danno in uscita un cluster che contiene eventuali errori.\\
Al di fuori di questa flat sequence è presente del codice per caricare un file che contiene dati utilizzati successivamente per compiere alcuni calcoli.

\subsubsection{Secondo blocco}
Questo blocco è composto da un ciclo con al suo interno un'altra flat sequence. Il ciclo while è necessario per rendere il programma sensibile in qualsiasi momento al cambiamento di qualche impostazione (switch di un bottone booleano o del valore di un controllo); viene bloccato solo quando viene invocato lo stop, con l'apposito bottone. La flat sequence all'interno del ciclo è divisa in cinque blocchi che si descrivono qui di seguito.
\begin{itemize}
	\item Primo blocco. Contiene un ulteriore ciclo while. All'interno di questo ciclo troviamo alcune case structure che vengono eseguite solo nel caso in cui il controllo a cui sono associate assume un certo valore. La case structure associata al bottone booleano \textit{Save} permette di salvare i dati qualora questo venga premuto; il nome con cui viene salvato il file viene costruito dalla funzione di concatenazione di stringhe che ha in ingresso le impostazioni caratteristiche del programma nel momento in cui si decide di salvare. La case structure associata al bottone booleano \textit{Waveform Integral} calcola, se richiesto, l'integrale della lunghezza d'onda su un intervallo specificato. È presente una case structure associata a un'ulteriore bottone booleano di \textit{Save} che però al suo interno manca della funzione di concatenazione, il path del file viene infatti inserito manualmente dall'utente in un apposito controllo. Nella case structure associata al controllo booleano \textit{Load Coeff} è presente una funzione per caricare un file con certi valori che possono essere usati successivamente nel programma. La case structure associata al controllo \textit{Peak Detector} calcola, attraverso il subVI \emph{Waveform Peak Detection.vi} il numero di picchi sopra una certa soglia con relativa lunghezza d'onda. Un'altra case structure associata al controllo booleano \textit{Grating} discrimina in base al valore del grating il valore da dare in ingresso al monocromatore. È presente infatti un'altra flat sequence divisa in quattro blocchi: nel primo viene invocato il subVI \emph{Port \& Grating.vi} per impostare il grating e il tipo di input del monocromatore, nel secondo attraverso il subVI \emph{Spectral GOTO.vi} si richiede al monocromatore di portare i componenti interni alle posizioni inserite dell'utente, nel terzo con il subVI \emph{Slits.vi} si imposta la slit di entrata, nel quarto il subVI \emph{Spectral Position.vi} restituisce la lunghezza d'onda effettiva a cui si trova il monocromatore.
	\item Secondo blocco. Completamente dedicato alla fotocamera. Dapprima vengono invocati i subVI \emph{SCStopCoC.vi} e \emph{SCGetStatus.vi} che restituiscono le informazioni di temperatura e di due componenti della fotocamera. In seguito alla costruzione di un cluster contente le impostazioni della fotocamera vengono invocati i subVI \emph{New Delay and exposure formatter.vi} per la formattazione del ritardo e del tempo di esposizione e \emph{SCSetNewCoC.vi} per inviare le impostazioni alla fotocamera. L'ultimo subVI chiamato è \emph{SCRun.vi} che, come suggerisce il nome stesso, fa partire la fotocamera.
	\item Terzo blocco. Anche questo riguarda solo la fotocamera e contiene tre subVI. Il primo \emph{SCGetImageStatus.vi} è wrappato all'interno di un ciclo while ed è il subVI che permette l'acquisizione vera e proprio dell'immagine. I dati acquisiti con questo subVI vengono poi passati al subVI successivo, \emph{SCGetImageSize.vi}, che restituisce le dimensioni in pixel dell'immagine. I dati che escono da questo subVI sono date in ingresso al successivo, \emph{SCGet12BitImage}, che restituisce l'immagine. Infine attraverso una case structure viene commutato il valore del led \textit{Saturation} in base al valore dei pixel risultati dall'ultimo subVI.
	\item Quarto blocco. Contiene una case structure associata al bottone booleano \textit{Grating} che calcola i valori da inserire nel grafico che mostra lo spettro. Tali calcoli vengono effettuati a partire dalla dimensione della foto (che varia se è stato utilizzato un particolare binning) e dal valore di ogni pixel; per prima cosa vengono calcolati i valori delle lunghezze d'onda da visualizzare sull'asse orizzontale del grafico, in modo speculare rispetto al centro dell'immagine, e in seguito viene calcolata una media di un certo numero di pixel (dati dal controllo \textit{Pixel to Average}) per i valori da visualizzare nell'asse verticale del grafico.
	\textbf{Mancano le formule da inserire}
In questa case structure ne è contenuta anche una associata al bottone booleano \textit{Subtract Dark} per eliminare un eventuale background acquisito in precedenza. 
	\item Quinto blocco. Consente al programma di visualizzare l'immagine o lo spettro, in base alla scelta dell'utente. In questo punto del programma vengono anche effettuati i calcoli dei valori \textit{FWHM}, \textit{Max Peak} e \textit{WL}.
\end{itemize}

\subsubsection{Terzo blocco}
Questo blocco contiene solamente il subVI \emph{SCSetMode.vi} che termina il funzionamento della fotocamera attraverso il valore adatto di un enumerativo. Anche se quest'ultimo passaggio potrebbe sembrare inutile è sempre bene ricordare che tutti i programmi che vengono eseguiti impiegano un certo numero di risorse: utilizzare le giuste funzioni o i giusti subVI di chiusura anche per gli strumenti coinvolti permette di liberare le risorse impegnate senza scansando il rischio di un uso ridondante della memoria.

\section{Considerazioni sul progetto a livello di programmazione}
L'analisi del codice già esistente si è resa necessaria in quanto uno dei due strumenti, in particolare il monocromatore, non è stato sostituito. Ad una prima lettura superficiale il codice risulta funzionante. Tuttavia in seguito alla partecipazione ad un corso base del linguaggio grafico LabVIEW (LabVIEW Core 1 e LabVIEW Core 2) sono emersi alcuni difetti del codice.\\
Per prima cosa è evidente che il codice nel block diagram appare molto caotico e difficile tra decifrare; è servito infatti uno studio piuttosto lungo per comprendere la logica con cui è stato creato. Mancando di commenti e nomi chiari si rivela difficile intuire lo scopo di strutture, variabili e formule inserite. Un altro difetto, che si potrebbe considerare un vero e proprio errore di programmazione, è la mancata considerazione dell'andamento del flusso dei dati e l'uso massiccio di flat sequence: infatti è assolutamente sconsigliato utilizzare flat sequence in quanto forzano il flusso dei dati rischiando di creare errori altrimenti evitabili. È sempre un buon criterio di programmazione cercare di organizzare il codice in modo da sfruttare il normale flusso dei dati e manipolarlo allo scopo di ottenere la logica desiderata.\\
Si nota anche la totale assenza di subVI che aiutano a rendere il codice flessibile e decisamente più leggibile. Facendo un confronto con qualsiasi altro linguaggio di programmazione che utilizza linee di codice scritto, un programma diviso in più file in base a determinati criteri risulta molto più ordinato, organico e leggile di un programma scritto in unico file, lungo magari migliaia di righe, in cui si fatica a comprenderne la logica e lo scopo delle variabili. Lo stesso concetto vale per VI e subVI nel linguaggio di programmazione grafico LabVIEW.